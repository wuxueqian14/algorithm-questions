# 239. Sliding Window Maximum

## 优先队列

```cpp
常用操作：
小根堆
priority_queue <int,vector<int>,greater<int> > q;
大根堆
priority_queue <int,vector<int>,less<int> > q;
top, push, pop

自定义比较
struct cmp {
    bool operator()(T& a, T& b) {
        return data1 < data2;
    }
};
```

优先队列大根堆维护最大值和下标，每次添加元素检查最大值是否还在窗口内。

时间复杂度：O(nlogn)。
空间复杂度：O(n)。

```cpp
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        priority_queue<pair<int, int>> q;
        for (int i = 0; i < k; i++) {
            q.emplace(nums[i], i);
        }
        vector<int> ans;
        ans.push_back(q.top().first);
        for (int i = k; i < nums.size(); i++) {
            q.emplace(nums[i], i);
            // 最大值不在窗口内移除
            while (q.top().second <= i - k) {
                q.pop();
            }
            ans.push_back(q.top().first);
        }
        return ans;
    }
};
```

## 单调队列

使用deque双端队列构造单调队列，队头永远是当前窗口最大值，队尾是入口，队列从大到小排列。

时间复杂度：O(n)。

空间复杂度：O(n)。

```c
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        deque<int> dq;
        for (int i = 0; i < k; i++) {
            push(dq, nums[i]);
        }
        vector<int> ans;
        ans.push_back(dq.front());
        for (int i = k; i < nums.size(); i++) {
            push(dq, nums[i]);
            pop(dq, nums[i-k]);
            ans.push_back(dq.front());
        }
        return ans;
    }

    void push(deque<int>& dq, int n) {
        while (!dq.empty() && n > dq.back()) {
            dq.pop_back();
        }
        dq.push_back(n);
    }

    void pop(deque<int>& dq, int n) {
        if (dq.front() == n) {
            dq.pop_front();
        }
    }
};
```

> 两种解放的区别就是优先队列维护最大值O(logn)，单调队列手动维护O(1)。