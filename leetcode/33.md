# 33. 搜索旋转排序数组

## 二分查找

### 二次二分

先找到旋转位置，然后判断target可能在哪个区间内，再进行一次二分查找。

时间复杂度：O(logn)。

```java
class Solution {
    public int search(int[] nums, int target) {
        int l = 0, end = nums.length - 1, r = end - 1;
        while (l <= r) {
            int mid = l + (r - l) / 2;
            if (nums[mid] > nums[end]) {
                l = mid + 1;
            } else {
                r = mid - 1;
            }
        }
        int ans;
        if (target > nums[end]) {
            ans = binarySearch(nums, 0, r, target);
        } else {
            ans = binarySearch(nums, l, end, target);
        }
        return ans;
    }

    private int binarySearch(int[] nums, int l, int r, int target) {
        while (l <= r) {
            int mid = l + (r - l) / 2;
            if (nums[mid] == target) {
                return mid;
            } else if (nums[mid] > target) {
                r = mid - 1;
            } else {
                l = mid + 1;
            }
        }
        return -1;
    }
}
```

### 一次二分

根据判断mid与end的位置的大小，可以确定部分区间有序，进行区间划分。

红区间为target左边，蓝区间为target及其右边。

```java
class Solution {
    boolean isRed(int[] nums, int mid, int end, int target) {
        if (nums[mid] > nums[end]) {
            return nums[mid] >= target && target > nums[end];
        } else {
            return target < nums[mid] || target > nums[end];
        }
    }
    public int search(int[] nums, int target) {
        int l = 0, end = nums.length - 1, r = end;
        while (l <= r) {
            int mid = l + (r - l) / 2;
            if (nums[mid] == target) {
                return mid;
            }
            if (isRed(nums, mid, end, target)) {
                r = mid - 1;
            } else {
                l = mid + 1;
            }
        }
        return -1;
    }
}
```